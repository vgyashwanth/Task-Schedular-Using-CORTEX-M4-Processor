/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include"Tasks.h"
#include"StackAddressing.h"
#include"SysTick.h"
#include"IntExc.h"
#include"Mutex.h"
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void EnableSystemFaults(void);
void PendSVPriority(uint8_t val);
void SetPendSV(void);

extern uint32_t global_tick;

int main(void)
{   
    
  EnableSystemFaults();
	SetMSP();
  PendSVPriority(200);
  InitializeTasksPrivateStack();
  ConfigureSystickInterrupt(1000U);
  ChangeSPtoPSP();
  Task1();

  /* Loop forever */
	for(;;);
}


void SysTick_Handler(void){
   
  /*Update the global tick*/
    global_tick++;
  /* Change the state of task if requried block time is elapsed */
    UpdateTaskState();
  /* Trigger the PendSV_Handler by setting the pending bit */
    SetPendSV();

}
__attribute__((naked))void PendSV_Handler(void){
  /* When interrupt occur stacking will takeplace and psp get updated */
  /* MSP is used in handler mode for storing any intermediate values */
	/* Save the remaining register using updated psp */
  /*Save the content of the current task*/
  __asm volatile("PUSH {LR}");
  __asm volatile("MRS R0,PSP");
  __asm volatile("STMDB R0!,{R4-R11}"); /*storing and updating the psp*/
  __asm volatile("BL StoreCurrentPSP"); /* Inline because need to pass R0-Register */
    ScheduleTask();
  /*Retreving the content of the new task going to execute*/
    GetCurrentPSP();
  /* for unstacking the R4-R11 Registers */
  __asm volatile("LDMIA R0!,{R4-R11}");
  /* Update the psp value to unstack the interrupt stack frame and exit from the interrupt*/
  __asm volatile("MSR PSP,R0");
  __asm volatile("POP {LR}");
  __asm volatile("BX LR");
   

}


void EnableSystemFaults(void){

uint32_t * SHCRS =  (uint32_t*)0xE000ED24;

  *(SHCRS) |= ((1U<<18) | (1U<<17) |(1U<<16));


}
void PendSVPriority(uint8_t val){

    uint32_t * SHPR3 =  (uint32_t*)0xE000ED20;
    *SHPR3 |= (val<<16U); 

}
void SetPendSV(void){

     uint32_t * ICSR =  (uint32_t*)0xE000ED04;
     *ICSR |=(1U<<28);
  
}

void HardFault_Handler(void){

  /*Write code here*/

  uint32_t a = *((uint32_t *)0xE000ED2C);


}
void MemManage_Handler(void){
  
  /*Write code here*/

   uint32_t a = *((uint32_t *)0xE000ED28);


}
void BusFault_Handler(void){
 
  /*Write code here*/
 
   uint32_t a = *((uint32_t *)0xE000ED29);


}

void UsageFault_Handler(void){

   /*Write code here*/

   uint32_t a = *((uint32_t *)0xE000ED2A);


}


